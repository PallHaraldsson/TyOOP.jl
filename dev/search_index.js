var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TyOOP","category":"page"},{"location":"#TyOOP","page":"Home","title":"TyOOP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TyOOP为Julia提供一套完整的面向对象机制，设计上主要基于CPython的面向对象，对Julia做了适配。","category":"page"},{"location":"","page":"Home","title":"Home","text":"其功能一览如下：","category":"page"},{"location":"","page":"Home","title":"Home","text":"功能名 支持 注释\n点操作符 是 \n继承 是 基类、子类不能直接转换\n构造器和实例方法重载 是 基于多重分派\n多继承 是 MRO基于扩展的C3算法\nPython风格 properties 是 \n默认字段 是 \n泛型 是 \n接口 是 使用空结构体类型的基类\n权限封装(modifiers) 否 同Python\n类静态方法 否 与Julia常规使用冲突，且易替代\n元类(metaclass) 否 宏的下位替代，实际场景使用较少","category":"page"},{"location":"","page":"Home","title":"Home","text":"快速学习请参考TyOOP Cheat Sheet.","category":"page"},{"location":"#OO类型定义","page":"Home","title":"OO类型定义","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TyOOP支持定义class和struct，class使用@oodef mutable struct开头，struct使用@oodef struct开头。","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TyOOP\r\n@oodef struct MyStruct\r\n    a :: Int\r\n    function new(a::Int)\r\n        @mk begin\r\n            a = a\r\n        end\r\n    end\r\n    function f(self)\r\n        self.a\r\n    end\r\nend\r\n\r\n@oodef mutable struct MyClass\r\n    a :: Int\r\n    function new(a::Int)\r\n        @mk begin\r\n            a = a\r\n        end\r\n    end\r\n    function f(self)\r\n        self.a\r\n    end\r\nend","category":"page"},{"location":"#默认字段","page":"Home","title":"默认字段","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TyOOP支持默认字段。","category":"page"},{"location":"","page":"Home","title":"Home","text":"在为类型定义一个字段时，如果为这个字段指定默认值，那么@mk宏允许缺省该字段的初始化。注意，如果不定义new函数并使用@mk宏，默认字段将无效。","category":"page"},{"location":"","page":"Home","title":"Home","text":"function get_default_field2()\r\n    println(\"default field2!\")\r\n    return 30\r\nend\r\n\r\n@oodef struct MyType\r\n    field1 :: DataType = MyType\r\n    field2 :: Int = get_default_field2()\r\n\r\n    function new()\r\n        return @mk\r\n    end\r\n\r\n    function new(field2::Integer)\r\n        return @mk field2 = field2\r\n    end\r\nend\r\n\r\njulia> MyType()\r\ndefault field2!\r\nMyType(MyType, 30)\r\n\r\njulia> MyType(50)\r\nMyType(MyType, 50)","category":"page"},{"location":"","page":"Home","title":"Home","text":"关于默认字段的注意点：","category":"page"},{"location":"","page":"Home","title":"Home","text":"默认字段没有性能开销。","category":"page"},{"location":"","page":"Home","title":"Home","text":"在@mk块显式指定字段初始化时，默认字段的表达式不会被求值。","category":"page"},{"location":"","page":"Home","title":"Home","text":"默认字段无法访问其他字段。","category":"page"},{"location":"#类型构造器","page":"Home","title":"类型构造器","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"上述代码中，function new(...)用于定义构造器。 构造器的返回值应当使用@mk begin ... end构造一个当前类型的实例，其中，begin语句块中使用字段名=值初始化字段。","category":"page"},{"location":"","page":"Home","title":"Home","text":"缺省构造器的行为：","category":"page"},{"location":"","page":"Home","title":"Home","text":"当类型为class，所有字段未初始化。\n当类型为struct，且存在字段，使用Julia生成的构造器(dataclass)","category":"page"},{"location":"","page":"Home","title":"Home","text":"构造器可以被重载。对于空间占用为0的结构体(单例类型)，构造器可以省略。","category":"page"},{"location":"#Python风格的构造器","page":"Home","title":"Python风格的构造器","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"以往的OO语言，如Python/C++/Java/C#，没有原生的不可变类型，因此构造器函数一般设计为","category":"page"},{"location":"","page":"Home","title":"Home","text":"创建一个新对象self(或this)\n利用构造器参数对self进行初始化","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia也支持这样的构造方式，但只对mutable struct有效。写法如下:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef mutable struct MySubclass <: {MySuperclass1, MySuperclass2}\r\n    field1\r\n    function new()\r\n        self = new()\r\n        set_base!(self, MySuperclass1()) # 初始化基类 MySuperclass1\r\n        set_base!(self, MySuperclass2()) # 初始化基类 MySuperclass2\r\n        self.field1 = ... # 初始化字段\r\n        return self\r\n    end","category":"page"},{"location":"#实例方法","page":"Home","title":"实例方法","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"实例方法须以function 方法名(类实例, ...)开头。类实例变量推荐写为self。","category":"page"},{"location":"","page":"Home","title":"Home","text":"前面代码里MyClass和MyStruct都实现了实例方法f, 它们的实例，比方说instance::MyClass，以instance.f()的语法调用该方法。","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef mutable struct MyClass\r\n    a :: Int\r\n    # ... 省略部分定义\r\n    function f(self)\r\n        self.a\r\n    end\r\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"实例方法支持任意形式的Julia参数，如变长参数，关键字参数，变长关键字参数，默认参数，默认关键字参数。","category":"page"},{"location":"","page":"Home","title":"Home","text":"此外，实例方法支持泛型，且能被重载。","category":"page"},{"location":"","page":"Home","title":"Home","text":"P.S: 如果要标注self参数的类型，应该使用self :: @like(MyClass)而不是self :: MyClass。这是因为实例方法可能被子类调用，而Julia不能支持隐式转换。","category":"page"},{"location":"","page":"Home","title":"Home","text":"P.P.S: 什么是@like？对于一个OO类型Parent, 任何继承自Parent的子类Child满足Child <: @like(Parent)，其中<:是Julia原生的subtyping运算。","category":"page"},{"location":"#继承，多继承","page":"Home","title":"继承，多继承","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"下面是一个简单的继承例子。","category":"page"},{"location":"","page":"Home","title":"Home","text":"首先我们定义两个结构体类型。","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct A\r\n    a :: Int\r\nend\r\n\r\n@oodef struct B\r\n    b :: Int\r\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"随后，我们用一个类型C继承上面两个类型。","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct C <: {A, B}\r\n    c :: String\r\n    function new(a::Int, b::Int, c::String = \"somestring\")\r\n        @mk begin\r\n            A(a), B(b)\r\n            c = c\r\n        end\r\n    end\r\nend\r\n\r\nc = C(1, 2)\r\n@assert c.a === 1\r\n@assert c.b === 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"可以看到，我们使用在@mk块中使用Base1(arg1, arg2), Base2(arg1, arg2)来设置基类，这和Python中的基类.__init__(self, args...)一致。","category":"page"},{"location":"","page":"Home","title":"Home","text":"一个子类可以继承多个基类，当多个基类出现重名属性时，使用C3线性化算法进行method resolution。","category":"page"},{"location":"","page":"Home","title":"Home","text":"下面这个例子给了一种常见的继承应用方式： Mixin。","category":"page"},{"location":"","page":"Home","title":"Home","text":"我们定义一个基类，多边形IPolygon，它的子类可能有正方形、长方形、三角形乃至一般的多边形，但这些子类都共享一个标准的周长求解算法：将所有边的长度相加。","category":"page"},{"location":"","page":"Home","title":"Home","text":"则多边形的基类，可以用如下代码定义：","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TyOOP\r\n\r\nconst Point = Tuple{Float64, Float64}\r\nfunction distance(source::Point, destination::Point)\r\n    sqrt(\r\n        (destination[1] - source[1]) ^ 2 +\r\n        (destination[2] - source[2]) ^ 2)\r\nend\r\n\r\n@oodef struct IPolygon\r\n    # 抽象方法\r\n    function get_edges end\r\n\r\n    # mixin方法\r\n    function get_perimeter(self)\r\n        s = 0.0\r\n        vs = self.get_edges() :: AbstractVector{Point}\r\n        if length(vs) <= 1\r\n            0.0\r\n        end\r\n        last = vs[1] :: Point\r\n        for i = 2:length(vs)\r\n            s += distance(vs[i], last)\r\n            last = vs[i]\r\n        end\r\n        s += distance(vs[end], vs[1])\r\n        return s\r\n    end\r\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"利用上述基类IPolygon，我们可以实现子类，并复用其中的get_perimeter方法。","category":"page"},{"location":"","page":"Home","title":"Home","text":"例如，矩形Rectangle：","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct Rectangle <: IPolygon\r\n    width :: Float64\r\n    height :: Float64\r\n    center :: Point\r\n\r\n    function new(width::Float64, height::Float64, center::Point)\r\n        @mk begin\r\n            width = width\r\n            height = height\r\n            center = center\r\n        end\r\n    end\r\n\r\n    function get_edges(self)\r\n        x0 = self.center[1]\r\n        y0 = self.center[2]\r\n        h = self.height / 2\r\n        w = self.width / 2\r\n        Point[\r\n            (x0 - w, y0 - h),\r\n            (x0 - w, y0 + h),\r\n            (x0 + w, y0 + h),\r\n            (x0 + w, y0 - h)\r\n        ]\r\n    end\r\n\r\n    # 对特殊的子类，可以重写 get_perimeter 获得更快的求周长方法\r\n    # function get_perimeter() ... end\r\nend\r\n\r\nrect = Rectangle(3.0, 2.0, (5.0, 2.0))\r\n@assert Arect.get_perimeter() == 10.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"P.S: 由TyOOP定义的OO类型，只能继承其他OO类型。","category":"page"},{"location":"#Python风格的properties","page":"Home","title":"Python风格的properties","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"在Java中，getter函数(get_xxx)和setter(set_xxx)函数用来隐藏类型字段的实现细节。","category":"page"},{"location":"","page":"Home","title":"Home","text":"对于其中冗余，很多语言如Python提供了一种语法糖，允许抽象self.xxx和self.xxx = value，这就是property。","category":"page"},{"location":"","page":"Home","title":"Home","text":"TyOOP支持property，有两种方式：","category":"page"},{"location":"","page":"Home","title":"Home","text":"第一种方式是定义get_xxx和set_xxx函数，这适合Java背景的工作人员过渡：","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct DemoProp\r\n    function get_value(self)\r\n        return 100\r\n    end\r\n    function set_value(self, value)\r\n        println(\"setting $value\")\r\n    end\r\nend\r\n\r\n# Java风格的getter, setter\r\nprintln(DemoProp().get_value()) # => 100\r\n\r\nDemoProp().set_value(200) # => setting 200","category":"page"},{"location":"","page":"Home","title":"Home","text":"与此同时，get_xxx会自动定义Python风格的getter property。","category":"page"},{"location":"","page":"Home","title":"Home","text":"DemoProp().value # => 100","category":"page"},{"location":"","page":"Home","title":"Home","text":"set_xxx则会定义Python风格的setter property。","category":"page"},{"location":"","page":"Home","title":"Home","text":"DemoProp().value = 200 # => setting 200","category":"page"},{"location":"","page":"Home","title":"Home","text":"当熟悉这种抽象后，可以使用第二种方式，这适合Python、C#等背景的工作人员：","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef mutable struct Square\r\n    side :: Float64\r\n    function new(side::Number)\r\n        @mk begin\r\n            side = convert(Float64, side)\r\n        end\r\n    end\r\n\r\n    @property(area) do\r\n        get = self -> self.side ^ 2\r\n        set = function (self, value)\r\n            self.side = sqrt(value)\r\n        end\r\n    end\r\nend\r\n\r\nsquare = Square(5) # => Square(5.0)\r\nsquare.area # => 25.0\r\nsquare.area = 16 # => 16\r\nsquare.side # => 4.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"可以看到，在设置面积的同时，正方形的边长得到相应改变。","category":"page"},{"location":"#高级特性：抽象方法和抽象property","page":"Home","title":"高级特性：抽象方法和抽象property","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@oodef struct AbstractSizedContainer{ElementType}\r\n\r\n    # 定义一个抽象方法\r\n    function contains end\r\n\r\n\r\n    # 定义一个抽象getter\r\n    @property(length) do\r\n        get\r\n    end\r\n    # 也可以定义抽象方法 'get_length'\r\nend\r\n\r\n# 打印未实现的方法（包括property）\r\nTyOOP.check_abstract(AbstractSizedContainer)\r\n# =>\r\n# Dict{PropertyName, TyOOP.CompileTime.PropertyDefinition} with 2 entries:\r\n#  contains (getter) => PropertyDefinition(:contains, missing, AbstractSizedContainer, MethodKind)\r\n#  length (getter)   => PropertyDefinition(:length, missing, AbstractSizedContainer, GetterPropertyKind)\r\n\r\n@oodef struct MyNumSet{E <: Number} <: AbstractSizedContainer{E}\r\n    inner :: Set{E}\r\n    function new(args::E...)\r\n        @mk begin\r\n            inner = Set{E}(args)\r\n        end\r\n    end\r\n\r\n    # if no annotations for 'self',\r\n    # annotations and type parameters can be added like:\r\n    # 'function contains(self :: @like(MySet{E}), e::E) where E'\r\n    function contains(self, e::E)\r\n        return e in self.inner\r\n    end\r\n\r\n    @property(length) do\r\n        get = self -> length(self.inner)\r\n    end\r\nend\r\n\r\nmy_set = MySet(1, 2, 3)\r\nmy_set.length # => 3\r\nmy_set.contains(2) # => true","category":"page"},{"location":"#高级特性：泛型","page":"Home","title":"高级特性：泛型","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"泛型无处不在，业务中常见于容器。","category":"page"},{"location":"","page":"Home","title":"Home","text":"在抽象方法一节，我们介绍了AbstractSizedContainer，可以看到它有一个泛型参数ElementType。","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct AbstractSizedContainer{ElementType}\r\n    function contains end\r\n    function get_length end\r\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"虽然在定义时没有用到这个类型，但在子类定义时，该类型参数能用来约束容器的元素类型。","category":"page"},{"location":"","page":"Home","title":"Home","text":"TyOOP能使用各种形式的Julia泛型，下面是一些例子。","category":"page"},{"location":"","page":"Home","title":"Home","text":"# 数字容器\r\n@oodef struct AbstactNumberContainer{ElementType <: Number}\r\n    ...\r\nend\r\n\r\n# 用来表示任意类型的可空值\r\n@oodef struct Optional{T}\r\n    value :: Union{Nothing, Some{T}}\r\nend","category":"page"},{"location":"#显式泛型类型参数","page":"Home","title":"显式泛型类型参数","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"下面的代码给出一个特别的例子，构造器new无法从参数类型推断出MyGenType{A}中的泛型类型参数A。","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct MyGenType{A}\r\n    a :: Int\r\n    function new(a::Int)\r\n        new{A}(a)\r\n    end\r\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"在这种情况下，可以显式指定泛型类型参数，构造类型实例：","category":"page"},{"location":"","page":"Home","title":"Home","text":"my_gen_type = MyGenType{String}(1)\r\nmy_gen_type = MyGenType{Number}(1)\r\nmy_gen_type = MyGenType{Vector{Int}}(1)","category":"page"},{"location":"#高级特性：接口","page":"Home","title":"高级特性：接口","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TyOOP支持接口编程：使用@oodef struct定义一个没有字段的结构体类型，为它添加一些抽象方法，这样就实现了接口。","category":"page"},{"location":"","page":"Home","title":"Home","text":"除开业务上方便对接逻辑外，接口还能帮助抽象。","category":"page"},{"location":"","page":"Home","title":"Home","text":"下面的代码基于接口HasLength定义一个普通的Julia函数a_regular_julia_function：","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct HasLength\r\n    function get_length end\r\nend\r\n\r\nfunction a_regular_julia_function(o :: @like(HasLength))\r\n    function some_random_logic(i::Integer)\r\n        (i * 3 + 5) ^ 2\r\n    end\r\n    some_random_logic(o.get_length()) # 或者 o.length\r\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"其中，@like宏作用将实际类型变成接口类型。","category":"page"},{"location":"","page":"Home","title":"Home","text":"在Julia的类型系统和多重分派中，具体的Julia类型不能被继承；而@like(ootype)唯一地将类型ootype转为Julia类型系统中能被继承的抽象类型，使得我们的OO系统能和Julia的多重分派一同工作。~~这是本项目的主要含金量。~~","category":"page"},{"location":"","page":"Home","title":"Home","text":"现在，我们为HasLength实现一个子类MyList，作为Vector类型的包装：","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct MyList{T} <: HasLength\r\n    inner :: Vector{T}\r\n\r\n    function new(elts::T...)\r\n        @mk begin\r\n            inner = collect(T, elts)\r\n        end\r\n    end\r\n\r\n    function get_length(self)\r\n        length(self.inner)\r\n    end\r\nend\r\n\r\na_regular_julia_function(MyList(1, 2, 3)) # 196\r\na_regular_julia_function([1]) # error","category":"page"},{"location":"","page":"Home","title":"Home","text":"可以看到，只有实现了HasLength的OO类型可以应用a_regular_julia_function。","category":"page"},{"location":"","page":"Home","title":"Home","text":"此外，我们指出，对于一个功能，如果在原生Julia实现下没有性能损失，TyOOP的接口编程也同样能不产生性能损失。","category":"page"},{"location":"","page":"Home","title":"Home","text":"@code_typed a_regular_julia_function(MyList(1, 2, 3))\r\nCodeInfo(\r\n1 ─ %1 = (getfield)(o, :inner)::Vector{Int64}\r\n│   %2 = Base.arraylen(%1)::Int64\r\n│   %3 = Base.mul_int(%2, 3)::Int64\r\n│   %4 = Base.add_int(%3, 5)::Int64\r\n│   %5 = Base.mul_int(%4, %4)::Int64\r\n└──      return %5\r\n) => Int64\r\n\r\njulia> @code_llvm a_regular_julia_function(MyList(1, 2, 3))\r\n;  @ REPL[6]:1 within `a_regular_julia_function`\r\n; Function Attrs: uwtable\r\ndefine i64 @julia_a_regular_julia_function_1290({ {}* }* nocapture nonnull readonly align 8 dereferenceable(8) %0) #0 {\r\ntop:\r\n    %1 = bitcast { {}* }* %0 to { i8*, i64, i16, i16, i32 }**\r\n    %2 = load atomic { i8*, i64, i16, i16, i32 }*, { i8*, i64, i16, i16, i32 }** %1 unordered, align 8\r\n    %3 = getelementptr inbounds { i8*, i64, i16, i16, i32 }, { i8*, i64, i16, i16, i32 }* %2, i64 0, i32 1\r\n    %4 = load i64, i64* %3, align 8\r\n    %5 = mul i64 %4, 3\r\n    %6 = add i64 %5, 5\r\n    %7 = mul i64 %6, %6\r\n  ret i64 %7\r\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"P.S: 为接口增加默认方法可以实现著名的Mixin抽象。见继承，多继承中的IPolygon类型。","category":"page"},{"location":"#@typed_access","page":"Home","title":"@typed_access","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia点操作符实际上是getproperty/setproperty!，因为编译器优化原因，使用Python风格的property会导致类型推导不够精准，降低性能。 对于可能的性能损失，我们提供@typed_access宏，在兼容julia原生语义的条件下，自动优化所有的a.b操作。","category":"page"},{"location":"","page":"Home","title":"Home","text":"@typed_access begin\r\n    instance1.method(instance2.property)\r\nend\r\n\r\n# 等价于\r\n\r\nTyOOP.typed_access(instance1, Val(:method))(\r\n    TyOOP.typed_access(instance, Val(:property))\r\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"@typed_access让动态分派更慢，让静态分派更快。对于a.b，如果a的类型被Julia成功推断，则@typed_access a.b不会比a.b慢。","category":"page"},{"location":"#Benchmark","page":"Home","title":"Benchmark","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"我们使用class或struct做嵌套继承，并测试访问基类字段、方法的性能。property是方法语法糖，因此不单独进行测试。","category":"page"},{"location":"","page":"Home","title":"Home","text":"类型hierarchy:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Base1\n字段: a\n方法: identity_a(返回实例本身)\n子类: Base2\n字段: b\n方法: identity_b(返回实例本身)\n子类: Base3\n字段: c\n方法: identity_c(返回实例本身)\n子类: Base4\n字段: d\n方法: identity_d(返回实例本身)\n子类: Base5\n字段: e\n方法: identity_e(返回实例本身)","category":"page"},{"location":"","page":"Home","title":"Home","text":"测试结果：","category":"page"},{"location":"","page":"Home","title":"Home","text":"测试例子 class或struct或Python class 运行时间 说明\n获取最顶层基类字段 class 15.4 ns \n获取最顶层基类字段 struct 18.3 ns \n获取最顶层基类字段 Python class 25.6 ns inline cache，平均常数时间访问字段\n调用最顶层方法 class 24.8 ns \n调用最顶层方法 struct 35.2 ns \n调用最顶层方法 Python class 63.2 ns inline cache，平均常数时间访问方法\n数组获取基类字段并求和 class 19.9 us \n数组获取基类字段并求和 struct 6.64 us \n数组获取基类字段并求和 Python class 410 us ","category":"page"},{"location":"","page":"Home","title":"Home","text":"注：当使用原生Julia时，连续字段访问与TyOOP访问基类字段，无性能差异；对于方法访问，将实例作为参数直接传递给对应类方法，性能等同于TyOOP的方法调用相同，无论方法是否嵌套。这说明使用TyOOP有助于更方便地达到Julia最佳性能。","category":"page"},{"location":"cheat-sheet/#TyOOP-Cheat-Sheet","page":"Cheat Sheet","title":"TyOOP Cheat Sheet","text":"","category":"section"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"TyOOP为Julia提供面向对象编程的功能，支持多继承、点操作符取成员、Python风格的properties以及接口编程。","category":"page"},{"location":"cheat-sheet/#.-类型定义","page":"Cheat Sheet","title":"1. 类型定义","text":"","category":"section"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"定义不可变的OO结构体。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef struct ImmutableData\r\n    x :: Int\r\n    y :: Int\r\n\r\n    function new(x::Int, y::Int) \r\n        @mk begin\r\n            x = x\r\n            y = y\r\n        end\r\n    end\r\nend\r\n\r\nd = ImmutableData(1, 2)\r\nx = d.x","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"其中，new是构造器函数。构造器和方法都可以重载。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@mk语句块产生当前类型的实例，在随后的语句块中，形如a = b是设置字段，形如BaseClass(arg1, arg2)是基类初始化。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"定义可变的OO结构体（class）。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef mutable struct MutableData\r\n    x :: Int\r\n    y :: Int\r\n\r\n    function new(x::Int, y::Int) \r\n        @mk begin\r\n            x = x\r\n            y = y\r\n        end\r\n    end\r\nend\r\n\r\nmt = MutableData(1, 2)\r\nmt.x += 1","category":"page"},{"location":"cheat-sheet/#默认字段","page":"Cheat Sheet","title":"默认字段","text":"","category":"section"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"TyOOP支持默认字段。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"在为类型定义一个字段时，如果为这个字段指定默认值，那么@mk宏允许缺省该字段的初始化。注意，如果不定义new函数并使用@mk宏，默认字段将无效。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef struct MyType\r\n    field1 :: DataType = MyType\r\n    field2 :: Int = 30\r\n\r\n    function new()\r\n        return @mk\r\n    end\r\nend\r\n\r\njulia> MyType()\r\nMyType(MyType, 30)","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"关于默认字段的注意点：","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"默认字段没有性能开销。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"在@mk块显式指定字段初始化时，默认字段的表达式不会被求值。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"默认字段无法访问其他字段。","category":"page"},{"location":"cheat-sheet/#.-继承","page":"Cheat Sheet","title":"2. 继承","text":"","category":"section"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef mutable struct Animal\r\n    name :: String\r\n    function new(theName::String)\r\n        @mk begin\r\n            name = theName\r\n        end\r\n    end\r\n\r\n    function move(self, distanceInMeters::Number = 0)\r\n        println(\"$(self.name) moved $(distanceInMeters)\")\r\n    end\r\nend\r\n\r\n@oodef mutable struct Snake <: Animal\r\n    function new(theName::String)\r\n        @mk begin\r\n            Animal(theName) # 初始化基类\r\n        end\r\n    end\r\n\r\n    function snake_check(self)\r\n        println(\"Calling a snake specific method!\")\r\n    end\r\nend\r\n\r\nsam = Snake(\"Sammy the Python\")\r\nsam.move()\r\n# Sammy the Python moved 0\r\nsam.snake_check()\r\n# Calling a snake specific method!","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"此外，以下需要非常注意！","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Snake <: Animal # false\r\nSnake(\"xxx\") isa Animal # false","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"记住，Julia原生类型系统并不理解两个class的子类型关系！详见基于接口的多态抽象。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"你应该使用下列方法测试继承关系：","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"issubclass(Snake, Animal) # true\r\nisinstance(Snake(\"xxx\"), Animal) # true\r\nSnake(\"xxx\") isa @like(Animal) # true","category":"page"},{"location":"cheat-sheet/#.-Properties","page":"Cheat Sheet","title":"4. Properties","text":"","category":"section"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef mutable struct Square\r\n    side :: Float64\r\n\r\n    @property(area) do\r\n        get = self -> self.side ^ 2\r\n        set = (self, value::Number) -> self.side = convert(Float64, sqrt(value))\r\n    end\r\nend\r\n\r\nsquare = Square()\r\nsquare.side = 10\r\n# call getter\r\nsquare.area # 100.0\r\n\r\n# call setter\r\nsquare.area = 25\r\nsquare.side # 5.0","category":"page"},{"location":"cheat-sheet/#.-接口","page":"Cheat Sheet","title":"5. 接口","text":"","category":"section"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"接口类型，是大小为0(sizeof(t) == 0)的不可变OO类型。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"接口类型实例的构造器是自动生成的，但也可以手动定义。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"下面的HasLength是接口类型。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef struct HasLength\r\n    @property(len) do\r\n        get  #= 抽象property: len =#\r\n    end\r\nend\r\n\r\n@oodef struct Fillable\r\n    function fill! end # 空函数表示抽象方法\r\n\r\n    # 定义一个抽象的setter, 可以为全体元素赋值\r\n    @property(allvalue) do\r\n        set\r\n    end\r\nend\r\n\r\n@oodef struct MyVector{T} <: {HasLength, Fillable}  # 多继承\r\n    xs :: Vector{T}\r\n    function new(xs::Vector{T})\r\n        @mk begin\r\n            xs = xs\r\n        end\r\n    end\r\nend\r\n\r\ncheck_abstract(MyVector)\r\n# Dict{PropertyName, TyOOP.CompileTime.PropertyDefinition} with 3 entries:\r\n#   fill! (getter)    => PropertyDefinition(:fill!, missing, :((Main).Fillable), MethodKind)\r\n#   len (getter)      => PropertyDefinition(:len, missing, :((Main).HasLength), GetterPropertyKind)\r\n#   allvalue (setter) => PropertyDefinition(:allvalue, missing, :((Main).Fillable), SetterPropertyKind)","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"isempty(check_abstract(MyVector))不为true，表示MyVector是抽象类型，需要实现相应属性或方法len, fill!和allvalue。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef struct MyVector{T} <: {HasLength, Fillable}  # 多继承\r\n    # 旧代码\r\n    xs :: Vector{T}\r\n    function new(xs::Vector{T})\r\n        @mk begin\r\n            xs = xs\r\n        end\r\n    end\r\n\r\n    # 新增代码\r\n    @property(len) do\r\n        get = self -> length(self.xs)\r\n    end\r\n\r\n    @property(allvalue) do\r\n        set = (self, value::T) -> fill!(self.xs, value)\r\n    end\r\n\r\n    function fill!(self, v::T)\r\n        self.allvalue = v\r\n    end\r\nend\r\n\r\nvec = MyVector([1, 2, 3])\r\nvec.allvalue = 4\r\nvec\r\n# MyVector{Int64}([4, 4, 4], HasLength(), Fillable())\r\nvec.len\r\n# 3\r\nvec.fill!(10)\r\nvec\r\n# MyVector{Int64}([10, 10, 10], HasLength(), Fillable())","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"此外，接口最重要的目的是基于接口的多态抽象。见下文基于接口的多态抽象。","category":"page"},{"location":"cheat-sheet/#.-多继承","page":"Cheat Sheet","title":"6. 多继承","text":"","category":"section"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"MRO(方法解析顺序)使用Python C3算法，所以多继承行为与Python一样。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef struct A\r\n    function calla(self) \"A\" end\r\n    function call(self) \"A\" end\r\nend\r\n\r\n@oodef struct B <: A\r\n    function callb(self) \"B\" end\r\n    function call(self) \"B\" end\r\nend\r\n\r\n@oodef mutable struct C <: A\r\n    function callc(self) \"C\" end\r\n    function call(self) \"C\" end\r\nend\r\n\r\n@oodef struct D <: {A, C, B}\r\n    function new()\r\n        @mk begin\r\n            A() # 可省略，因为A是接口类型\r\n            B() # 可省略，因为B是接口类型\r\n            C() # 不可省略，因为C是可变类型\r\n            # 基类初始化可写成一行: A(), B(), C()\r\n        end\r\n    end\r\nend\r\n\r\nd = D()\r\nd.calla() # A\r\nd.callb() # B\r\nd.callc() # C\r\nd.call() # C\r\n[x[1] for x in ootype_mro(typeof(d))]\r\n# 4-element Vector{DataType}:\r\n#  D\r\n#  C\r\n#  B\r\n#  A","category":"page"},{"location":"cheat-sheet/#.-基于接口的多态抽象","page":"Cheat Sheet","title":"7. 基于接口的多态抽象","text":"","category":"section"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"下面例子给出一个容易犯错的情况：","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef struct A end\r\n@oodef struct B <: A end\r\nmyapi(x :: A) = println(\"do something!\")\r\n\r\nmyapi(A())\r\n# do something!\r\n\r\nmyapi(B())\r\n# ERROR: MethodError: no method matching myapi(::B)","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"记住：Julia原生类型系统并不理解两个class的子类型关系！","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"如果希望Julia函数myapi的参数只接受A或A的子类型，应该这样实现：","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"myapi(x :: @like(A)) = println(\"do something!\")\r\n\r\nmyapi(B())\r\n# do something!\r\n\r\nmyapi([])\r\n# ERROR: MethodError: no method matching myapi(::Vector{Any})","category":"page"},{"location":"cheat-sheet/#.-一个机器学习的OOP实例","page":"Cheat Sheet","title":"8. 一个机器学习的OOP实例","text":"","category":"section"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"在下面这份代码里，我们实现一个使用最小二乘法训练的机器学习模型，并让其支持Julia中ScikitLearn的接口。通过下面代码，用户可以像使用一般ScikitLearn.jl的模型一样来调用这个模型，更可以在MLJ机器学习框架中使用这个模型，而不必关心该模型由面向对象还是多重分派实现。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"using TyOOP\r\n\r\n@oodef struct AbstractMLModel{X, Y}\r\n    function fit! end\r\n    function predict end\r\nend\r\n\r\nusing LsqFit\r\n\r\n@oodef mutable struct LsqModel{M<:Function} <: AbstractMLModel{Vector{Float64},Vector{Float64}}\r\n    model::M  # 一个函数，代表模型的公式\r\n    param::Vector{Float64}\r\n    function new(m::M, init_param::Vector{Float64})\r\n        @mk begin\r\n            model = m\r\n            param = init_param\r\n        end\r\n    end\r\n\r\n    function fit!(self, X::Vector{Float64}, y::Vector{Float64})\r\n        fit = curve_fit(self.model, X, y, self.param)\r\n        self.param = fit.param\r\n        self\r\n    end\r\n\r\n    function predict(self, x::Float64)\r\n        self.predict([x])\r\n    end\r\n\r\n    function predict(self, X::Vector{Float64})\r\n        return self.model(X, self.param)\r\n    end\r\nend\r\n\r\n# 例子来自 https://github.com/JuliaNLSolvers/LsqFit.jl\r\n\r\n@. model(x, p) = p[1] * exp(-x * p[2])\r\nclf = LsqModel(model, [0.5, 0.5])\r\nptrue = [1.0, 2.0]\r\nxdata = collect(range(0, stop = 10, length = 20));\r\nydata = collect(model(xdata, ptrue) + 0.01 * randn(length(xdata)));\r\n\r\nclf.fit!(xdata, ydata) # 训练模型\r\nclf.predict(xdata)  # 预测模型\r\nclf.param # 查看模型参数\r\n\r\n# ScikitLearnBase提供了fit!和predict两个接口函数。\r\n# 我们将TyOOP的接口(@like(...))和Julia接口对接。\r\n\r\nusing ScikitLearnBase\r\nScikitLearnBase.is_classifier(::@like(AbstractMLModel)) = true\r\nScikitLearnBase.fit!(clf::@like(AbstractMLModel{X, Y}), x::X, y::Y) where {X, Y} = clf.fit!(x, y)\r\nScikitLearnBase.predict(clf::@like(AbstractMLModel{X}), x::X) where X = clf.predict(x)\r\n\r\nScikitLearnBase.fit!(clf, xdata, ydata)\r\nScikitLearnBase.predict(clf, xdata)","category":"page"},{"location":"cheat-sheet/#.-性能问题","page":"Cheat Sheet","title":"9. 性能问题","text":"","category":"section"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"TyOOP本身和Julia原生代码一样快，但由于递归调用点操作符运算Base.getproperty的类型推断问题 (例如这个例子)，尽管大多数时候TyOOP编译出的机器码非常高效，但返回类型却忽然变成Any或某种Union类型。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"这可能带来性能问题。出现该问题的情况是有限的，问题场合如下：","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"使用Python风格的property\n在method里访问另一个成员，该成员再次递归调用点操作符","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"解决方案也很简单，使用@typed_access标注可能出现性能问题的代码即可。","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@typed_access my_instance.method()\r\n@typed_access my_instance.property","category":"page"},{"location":"cheat-sheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"注意：上述代码中请保证my_instance类型已知。如果@typed_access标注的代码存在动态类型或类型不稳定，可能导致更严重的性能问题。","category":"page"}]
}
